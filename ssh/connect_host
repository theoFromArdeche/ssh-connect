#!/bin/bash

SSH_CUSTOM_LOG=~/bin/ssh/ssh_custom.log
SSH_LOG=~/bin/ssh/ssh.log

# Ensure directories exist
mkdir -p ~/bin/ssh

: > "$SSH_CUSTOM_LOG"
: > "$SSH_LOG"

ssh_custom_log() {
  local timestamp msg plain_msg
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  msg="$1"
  plain_msg=$(echo -e "$msg" | sed 's/\x1b\[[0-9;]*m//g')

  echo -e "[$timestamp] $msg"
  echo "[$timestamp] $plain_msg" >> "$SSH_CUSTOM_LOG"
}

# Create named pipes
PIPE_LOG=$(mktemp -u)
mkfifo "$PIPE_LOG"

while IFS= read -r line; do
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $line" >> "$SSH_LOG"
done < "$PIPE_LOG" &
PIPE_LOG_PID=$!

PIPE_CUSTOM_LOG=$(mktemp -u)
mkfifo "$PIPE_CUSTOM_LOG"

while IFS= read -r line; do
  ssh_custom_log "$line"
done < "$PIPE_CUSTOM_LOG" &
PIPE_CUSTOM_LOG_PID=$!

PIPE_CUSTOM_LOG_MONITOR=$(mktemp -u)
mkfifo "$PIPE_CUSTOM_LOG_MONITOR"

while IFS= read -r line; do
  ssh_custom_log "$line"
done < "$PIPE_CUSTOM_LOG_MONITOR" &
PIPE_CUSTOM_LOG_MONITOR_PID=$!

if [ -z "$1" ]; then
  ssh_custom_log "\e[1;31mUsage: $0 <host> [--vnc] [--ports port1 port2 ...]\e[0m"
  exit 1
fi

TARGET_HOST="$1"
shift

USE_VNC=false
VNC_PORT=5901
PORTS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --vnc)
      if [ "$USE_VNC" = false ]; then
        USE_VNC=true
        PORTS+=("$VNC_PORT")
      fi
      shift
      ;;
    --ports)
      shift
      while [[ $# -gt 0 && ! "$1" == --* ]]; do
        PORTS+=("$1")
        shift
      done
      ;;
    *)
      ssh_custom_log "\e[1;31mUnknown argument: $1\e[0m"
      exit 1
      ;;
  esac
done

if [ ${#PORTS[@]} -eq 0 ]; then
  ssh_custom_log "\e[1;33mWarning: No ports specified for monitoring.\e[0m"
fi

FORWARDING=""
for PORT in "${PORTS[@]}"; do
  FORWARDING+="-L ${PORT}:localhost:${PORT} "
done

ssh_custom_log "\e[0;32mStarting SSH tunnel to $TARGET_HOST with ports: ${PORTS[*]}\e[0m"

ssh -N $FORWARDING "$TARGET_HOST" > "$PIPE_LOG" 2>&1 &
SSH_PID=$!

# Initialize PIDs
VNC_PID=""
MONITOR_LOCAL_PID=""

cleanup_flag=0
cleanup() {
  if [ $cleanup_flag -eq 1 ]; then return; fi
  cleanup_flag=1
  
  if [ "$USE_VNC" = true ]; then
    ssh_custom_log "\e[1;33mCleaning up SSH tunnel and VNC viewer...\e[0m"
  else
    ssh_custom_log "\e[1;33mCleaning up SSH tunnel...\e[0m"
  fi
  
  # Kill VNC viewer
  if [[ "$USE_VNC" = true && -n "$VNC_PID" ]] && kill -0 "$VNC_PID" 2>/dev/null; then
    kill "$VNC_PID" 2>/dev/null
  fi

  # Kill monitor_ports
  if [[ -n "$MONITOR_LOCAL_PID" ]] && kill -0 "$MONITOR_LOCAL_PID" 2>/dev/null; then
    kill "$MONITOR_LOCAL_PID" 2>/dev/null
  fi

  # Kill SSH
  if [[ -n "$SSH_PID" ]] && kill -0 "$SSH_PID" 2>/dev/null; then
    kill "$SSH_PID" 2>/dev/null
  fi

  # Kill logger processes
  kill "$PIPE_LOG_PID" "$PIPE_CUSTOM_LOG_PID" "$PIPE_CUSTOM_LOG_MONITOR_PID" 2>/dev/null

  # Remove pipes
  rm -f "$PIPE_LOG" "$PIPE_CUSTOM_LOG" "$PIPE_CUSTOM_LOG_MONITOR" 2>/dev/null

  exit 0
}

trap cleanup SIGINT SIGTERM EXIT

FLAG_TUNNEL_ACTIVE=false

for PORT in "${PORTS[@]}"; do
  for i in {1..20}; do
    # Use ss instead of nc -z to avoid triggering VNC blacklist
    # ss reads kernel socket table without making a TCP connection
    if ss -tln "sport = :$PORT" 2>/dev/null | grep -q "LISTEN"; then
      ssh_custom_log "\e[0;32mSSH tunnel is now active.\e[0m"
      FLAG_TUNNEL_ACTIVE=true
      break 2
    fi
    sleep 0.5
  done
done

if [ "$FLAG_TUNNEL_ACTIVE" = true ]; then
  if [ "$USE_VNC" = true ]; then
    vncviewer "localhost:$VNC_PORT" &
    VNC_PID=$!
  fi

  # ONLY monitor local ports - no remote monitoring
  monitor_ports "localhost" "${PORTS[@]}" > "$PIPE_CUSTOM_LOG_MONITOR" 2>&1 &
  MONITOR_LOCAL_PID=$!
  
  if [ "$USE_VNC" = true ]; then
    wait $VNC_PID
  else
    wait $SSH_PID
  fi
else
  ssh_custom_log "\e[1;31mFailed to establish SSH tunnel.\e[0m"
fi

cleanup
